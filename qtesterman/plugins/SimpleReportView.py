# -*- coding: utf-8 -*-
##
# This file is part of Testerman, a test automation system.
# Copyright (c) 2009 QTesterman contributors
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
##

##
# A plugin to display logs as a simple text summary.
#
##

from PyQt4.Qt import *
from PyQt4.QtXml import *
import PyQt4.QtWebKit as QtWebKit

from Base import *
from CommonWidgets import *

import Plugin
import PluginManager
import Documentation

import string
import os

# (almost) Velocity-compliant template engine
import airspeed


##############################################################################
# PLugin Constants
##############################################################################

# Plugin ID, as generated by uuidgen
PLUGIN_ID = "86d2d0a0-266e-4735-bb25-54378c7b1a1d"
VERSION = "1.0.0"
DESCRIPTION = """
A template-based reporter that creates text-based reports.<br />
Templates are Velocity-compliant. The following objects/variables
are made available to them:
<ul>
<li>Global variables:</li>
<pre>
	record of Testcase testcases,
	charstring ats_count,
	integer pass_count,
	integer fail_count,
	integer inconc_count,
	integer none_count,
	integer error_count
</pre>
<li>Types definition:</li>
<pre>
record Testcase {
	Ats ats,
	charstring id,
	charstring title,
	charstring verdict,
	charstring doc, // the full testcase docstring
	charstring description, // the non-tagged docstring part
	TaggedDescription tag, // a record of @tag names available in the docstring
}

record Ats {
	charstring id
}
</pre>
"""

DEFAULT_TEMPLATE_FILENAME = "templates/default-simple-report.txt"

##############################################################################
# Template Management (Models Management)
##############################################################################

class TemplateModel:
	def __init__(self, name = "Default", filename = '', displayAsHtml = False, uuid = None):
		self._name = name
		self._filename = filename
		self._displayAsHtml = displayAsHtml
		self._uuid = uuid
	
	def getName(self):
		return self._name
	
	def setName(self, name):
		self._name = name

	def getFilename(self):
		return self._filename
	
	def setFilename(self, filename):
		self._filename = filename

	def displayAsHtml(self):
		return self._displayAsHtml
	
	def setDisplayAsHtml(self, v = True):
		self._displayAsHtml = v

	def getUuid(self):
		return self._uuid


def loadTemplates():
	"""
	Loads templates properties from the settings,
	storing the templates as a collection of
	plugins/<uuid>/templates/<template-uuid>/{name,filename,displayAsHtml}
	QSettings keys.
	
	@rtype: list of TemplateModel
	@returns: the loaded templates. Contains a default one if the
	loaded list was empty.
	"""
	settings = QSettings()
	settings.beginGroup("plugins/%s/templates" % PLUGIN_ID)

	templateModels = []
	for group in settings.childGroups():
		# By construction, group is the UUID string identifying the template
		name = settings.value("%s/name" % group).toString()
		filename = settings.value("%s/filename" % group).toString()
		displayAsHtml = settings.value("%s/displayAsHtml" % group).toBool()
		templateModel = TemplateModel(name, filename, displayAsHtml, group)
		templateModels.append(templateModel)
	
	# Load a default template, if none exists
	if not templateModels:
		defaultTemplateFilename = os.path.normpath(unicode("%s/plugins/%s" % (QApplication.instance().get('qtestermanpath'), DEFAULT_TEMPLATE_FILENAME)))
		templateModels.append(TemplateModel("Default", defaultTemplateFilename, True))
	
	return templateModels

def saveTemplates(templateModels):
	"""
	Saves templates properties as a collection of 
	plugins/<uuid>/templates/<template-uuid>/{name,filename,displayAsHtml}
	QSettings keys.

	@type  templateModels: list of TemplateModel
	@param templateModels: the template to save to a persistent storage
	
	@rtype: boolean
	@returns: True if OK, False in case of an error
	"""
	settings = QSettings()
	settings.beginGroup("plugins/%s/templates" % PLUGIN_ID)

	# Clear all
	for group in settings.childGroups():
		settings.remove(group)

	# Reconstruct everything
	for templateModel in templateModels:
		group = templateModel.getUuid()
		if group is None:
			# New template - generates a new UUID
			group = QUuid.createUuid().toString()
		settings.beginGroup(group)
		settings.setValue("name", QVariant(templateModel.getName()))
		settings.setValue("filename", QVariant(templateModel.getFilename()))
		settings.setValue("displayAsHtml", QVariant(templateModel.displayAsHtml()))
		settings.endGroup()
	
	return True

##############################################################################
# Variables wrappers
##############################################################################

class AtsVariables:
	"""
	Behaves as a dict to access ats-related properties.
	"""
	def __init__(self, model):
		self._model = model
		# extract starttime/stoptime
		self._startTime = 0.0

	def __getitem__(self, name):
		if name == "id":
			return self._model.getId()
		elif name == "result":
			return self._model.getResult()
		else:
			raise KeyError(name)

class TestCaseVariables:
	"""
	Behaves as a dict to access testcase-related properties.
	"""
	def __init__(self, model):
		self._model = model
		self._atsVariables = AtsVariables(self._model.getAts())

		self._taggedDescription = Documentation.TaggedDocstring()
		self._taggedDescription.parse(self._model.getDescription())
		self._tags = Documentation.DictWrapper(self._taggedDescription)
		# extract starttime/stoptime
		self._startTime = 0.0
		self._stopTime = 0.0
		
		# extract user logs
		self._userLogs = [] # tuple of (timestamp, message)

	def appendLog(self, timestamp, log):
		self._logs.append((timestamp, log))
	
	def __getitem__(self, name):
		if name == "ats":
			return self._atsVariables
		elif name == "id":
			return self._model.getId()
		elif name == "title":
			return self._model.getTitle()
		elif name == "verdict":
			return self._model.getVerdict()
		elif name == "doc":
			# Complete, raw description
			return self._taggedDescription.getString()
		elif name == "description":
			# The untagged part of the docstring
			return self._taggedDescription[''].value()
		elif name == "tag":
			return self._tags
		elif name == "userlogs":
			ret = []
			for timestamp, log in self._userLogs:
				delta = timestamp - self._startTimestamp
				t = QTime().addMSecs(int(delta * 1000))
				ret.append('%s: %s' % (t.toString('+ hh:mm:ss.zzz'), log))
			return '\n'.join(ret)
		else:
			raise KeyError(name)

##############################################################################
# Custom web view
##############################################################################

class MyWebView(QtWebKit.QWebView):
	def __init__(self, manager, parent = None):
		QtWebKit.QWebView.__init__(self, parent)
		self._manager = manager
		self.setTextSizeMultiplier(0.8)
		reloadAction = self.pageAction(QtWebKit.QWebPage.Reload)
		reloadAction.setText("(Re)apply template")
		self.connect(reloadAction, SIGNAL('triggered(bool)'), self.reload)

	def reload(self):
		self._manager._applyTemplate()

##############################################################################
# Report View Plugin
##############################################################################

class WReportView(Plugin.WReportView):
	def __init__(self, parent = None):
		Plugin.WReportView.__init__(self, parent)
		self._source = None
		self.__createWidgets()
		self._refreshTemplates()

	##
	# Implementation specific
	##
	def __createWidgets(self):
		layout = QVBoxLayout()

		# A button bar with selectable template, save option, display as HTML option
		buttonLayout = QHBoxLayout()
		buttonLayout.addWidget(QLabel("Template:"))
		self._templateComboBox = QComboBox()
		buttonLayout.addWidget(self._templateComboBox)
		self._applyTemplateButton = QPushButton("Apply")
		buttonLayout.addWidget(self._applyTemplateButton)
		self._manageTemplatesButton = QPushButton("Manage templates...")
		buttonLayout.addWidget(self._manageTemplatesButton)
		self.connect(self._applyTemplateButton, SIGNAL('clicked()'), self._applyTemplate)
		self.connect(self._manageTemplatesButton, SIGNAL('clicked()'), self._manageTemplates)
		buttonLayout.addStretch()
		self._saveButton = QPushButton("Save as...")
		self.connect(self._saveButton, SIGNAL('clicked()'), self._saveAs)
		buttonLayout.addWidget(self._saveButton)
		self._saveButton.setEnabled(False)
		layout.addLayout(buttonLayout)

		# The main view
		self._webView = MyWebView(self)
		layout.addWidget(self._webView)

		self.setLayout(layout)

	def _manageTemplates(self):
		import Preferences
		dialog = Preferences.WPluginSettingsDialog("Manage templates", WPluginConfiguration, self)
		if dialog.exec_() == QDialog.Accepted:
			self._refreshTemplates()

	def _applyTemplate(self):
		self.clearLog()
		self.displayLog()

	def _saveAs(self):
		path = "plugins/%s/" % PLUGIN_ID
		settings = QSettings()
		directory = settings.value(path + 'lastVisitedDirectory', QVariant("")).toString()
		filename = QFileDialog.getSaveFileName(self, "Save report as...", directory)
		if filename.isEmpty():
			return False

		filename = unicode(filename)
		directory = os.path.dirname(filename)
		settings.setValue(path + 'lastVisitedDirectory', QVariant(directory))
		try:
			f = open(filename, 'w')
			# FIXME: won't save HTML code correctly
			f.write(self._source)
			f.close()
			QMessageBox.information(self, getClientName(), "Report saved successfully.", QMessageBox.Ok)
			return True
		except Exception, e:
			systemError(self, "Unable to save file as %s: %s" % (filename, unicode(e)))
			return False

	def _getSummaryVariables(self):
		"""
		Analyses the available log model, builds a list
		of dict usable for a summary template formatting.
		
		Provides the following template variables:
		
		for each testcase:
		ats-id, testcase-id, testcase-title, testcase-verdict
		
		summary/counts:
		ats-count, {pass,fail,inconc,none,error}-{count,ratio}
		"""
		count = 0
		counts = {}
		for s in ['pass', 'fail', 'inconc', 'none', 'error']:
			counts[s] = 0
		atsCount = 0

		testcaseSummaries = []
		for ats in self.getModel().getAtses():
			atsCount += 1
			for testcase in ats.getTestCases():
				if testcase.isComplete():
					v = testcase.getVerdict()
					if v in counts:
						counts[v] += 1
					count += 1

		summary = { 'testcase-count': count,
			'ats_count': atsCount,
			'pass_count': counts['pass'],
			'fail_count': counts['fail'],
			'inconc_count': counts['inconc'],
			'none_count': counts['none'],
			'error_count': counts['error'],
			'pass_ratio': count and '%2.2f' % (float(counts['pass'])/float(count)*100.0) or '100',
			'fail_ratio': count and '%2.2f' % (float(counts['fail'])/float(count)*100.0) or '0',
			'inconc_ratio': count and '%2.2f' % (float(counts['inconc'])/float(count)*100.0) or '0',
			'none_ratio': count and '%2.2f' % (float(counts['none'])/float(count)*100.0) or '0',
			'error_ratio': count and '%2.2f' % (float(counts['error'])/float(count)*100.0) or '0',
		}
		return summary

	def _getTestCasesVariables(self):
		"""
		Returns a list of testcases variables
		"""
		ret = []
		for ats in self.getModel().getAtses():
			for testcase in ats.getTestCases():
				if testcase.isComplete():
					ret.append(TestCaseVariables(testcase))
		return ret

	def _getTemplate(self):
		"""
		Returns the currently selected template,
		or None in case of a loading error.
		"""
		template = None
		displayAsHtml = False
		index = self._templateComboBox.currentIndex()
		if index >= 0:
			filename = self._templateComboBox.itemData(index, Qt.UserRole).toString()
			displayAsHtml = self._templateComboBox.itemData(index, Qt.UserRole+1).toBool()
			if not filename.isEmpty():
				try:
					f = open(unicode(filename))
					content = f.read()
					f.close()
					template = airspeed.Template(content)
				except Exception, e:
					# Instead of a popup, silently display the error message within the report.
					# Avoid popping an error when opening the log viewer with an incorrect plugin configuration.
					template = airspeed.Template("Unable to load template file '%s': %s" % (unicode(filename), str(e)))

		return (template, displayAsHtml)

	def _refreshTemplates(self):
		"""
		Refresh the template combobox according to available templates.
		"""
		self._templateComboBox.clear()
		templateModels = loadTemplates()
		for templateModel in templateModels:
			self._templateComboBox.addItem(templateModel.getName())
			self._templateComboBox.setItemData(self._templateComboBox.count()-1, QVariant(templateModel.getFilename()), Qt.UserRole)
			self._templateComboBox.setItemData(self._templateComboBox.count()-1, QVariant(templateModel.displayAsHtml()), Qt.UserRole+1)

	##
	# Plugin.WReportView reimplementation
	##
	def displayLog(self):
		self._source = None
		(template, displayAsHtml) = self._getTemplate()

		if not template:
			return

		summary = self._getSummaryVariables()
		testcases = self._getTestCasesVariables()
		variables = { 'summary': summary, 'testcases': testcases }
		
		if displayAsHtml:
			# converts \n in template values to <br>
			xform = lambda x: x.replace('\n', '<br />').strip()
		else:
			xform = None

		try:
			ret = template.merge(variables, xform = xform)
			self._source = ret
		except Exception, e:
			ret = str(e)

		if self._source is None or not displayAsHtml:
			self._webView.setHtml("<pre>%s</pre>" % ret)
		else:
			self._webView.setHtml(ret)

		if self._source is not None:
			self._saveButton.setEnabled(True)
		else:
			self._saveButton.setEnabled(False)

	def clearLog(self):
		"""
		Plugin reimplementation.
		"""
		self._webView.setHtml('')


##############################################################################
# Template Management (Plugin Configuration)
##############################################################################

class TemplateEditDialog(QDialog):
	def __init__(self, model = None, parent = None):
		QDialog.__init__(self, parent)
		self._model = model
		if self._model is None:
			self._model = TemplateModel()
		self.__createWidgets()
		self._load()

	def __createWidgets(self):
		self.setWindowTitle("Template Properties")
		self.setMinimumWidth(400)
		self.resize(QSize(600, 0))
		layout = QVBoxLayout()

		attributesLayout = QGridLayout()

		self._nameLineEdit = QLineEdit(self._model.getName())
		attributesLayout.addWidget(QLabel("Name:"), 0, 0, Qt.AlignRight)
		attributesLayout.addWidget(self._nameLineEdit, 0, 1, 1, 2)
		self._filenameLineEdit = QLineEdit(self._model.getFilename())
		attributesLayout.addWidget(QLabel("Filename:"), 1, 0, Qt.AlignRight)
		attributesLayout.addWidget(self._filenameLineEdit, 1, 1)
		self._browseFileButton = QPushButton("...")
		self.connect(self._browseFileButton, SIGNAL('clicked()'), self._browseFile)
		attributesLayout.addWidget(self._browseFileButton, 1, 2)
		self._displayAsHtmlCheckBox = QCheckBox("This template generates HTML")
		attributesLayout.addWidget(self._displayAsHtmlCheckBox, 2, 0, 1, 3)
		if self._model.displayAsHtml():
			self._displayAsHtmlCheckBox.setChecked(True)
		attributesLayout.setColumnStretch(1, 1)
		layout.addLayout(attributesLayout)

		self._textEdit = QTextEdit()
		self._textEdit.setMinimumHeight(200)
		self._textEdit.setUndoRedoEnabled(True)
		self._textEdit.setWordWrapMode(QTextOption.NoWrap)
		layout.addWidget(self._textEdit)

		# Buttons
		buttonLayout = QHBoxLayout()
		self._okButton = QPushButton("Ok")
		self.connect(self._okButton, SIGNAL("clicked()"), self.aboutToAccept)
		self._cancelButton = QPushButton("Cancel")
		self.connect(self._cancelButton, SIGNAL("clicked()"), self.reject)
		buttonLayout.addStretch()
		buttonLayout.addWidget(self._okButton)
		buttonLayout.addWidget(self._cancelButton)
		layout.addLayout(buttonLayout)

		self.setLayout(layout)

	def _browseFile(self):
		filename = QFileDialog.getOpenFileName(self, "Select Template File", self._filenameLineEdit.text())
		if not filename.isEmpty():
			self._filenameLineEdit.setText(filename)
			self._load()
	
	def _load(self):
		filename = self._filenameLineEdit.text()
		if not filename.isEmpty():
			try:
				f = open(unicode(filename))
				content = f.read().decode('utf-8')
				f.close()
			except:
				content = '(file not found/not readable)'
			self._textEdit.setPlainText(content)

	def _save(self):
		filename = self._filenameLineEdit.text()
		if not filename.isEmpty():
			f = open(unicode(filename), 'w')
			content = unicode(self._textEdit.toPlainText()).encode('utf-8')
			f.write(content)
			f.close()

	def updateModel(self):
		self._model.setName(self._nameLineEdit.text())
		self._model.setFilename(self._filenameLineEdit.text())
		self._model.setDisplayAsHtml(self._displayAsHtmlCheckBox.isChecked())

	def getModel(self):
		self.updateModel()
		return self._model

	def aboutToAccept(self):
		if self._textEdit.document().isModified():
			# Let's save the updated template
			try:
				self._save()
			except Exception, e:
				ret = QMessageBox.warning(self, "Error",
					"Unable to save template file '%s':\n%s\nContinue anyway ?" % (unicode(filename), str(e)),
					QMessageBox.Yes | QMessageBox.No)
				if ret == QMessageBox.No:
					return

		self.accept()

class TemplateItem(QTreeWidgetItem):
	def __init__(self, templateModel, parent):
		QTreeWidgetItem.__init__(self, parent)
		self.setText(0, templateModel.getName())
		self.setText(1, templateModel.getFilename())
		self._templateModel = templateModel

	def getModel(self):
		return self._templateModel

class WTemplateTreeView(QTreeWidget):
	def __init__(self, parent = None):
		QTreeWidget.__init__(self, parent)
		self.__createWidgets()
		self.__createActions()
		self._templateModels = []
		self.refresh()

	def __createWidgets(self):
		self.setRootIsDecorated(False)
		self.setSortingEnabled(True)
		self.setHeaderLabels(["Name", "Filename"])
		self.connect(self, SIGNAL("itemActivated(QTreeWidgetItem*, int)"), self.onItemActivated)
		self.setContextMenuPolicy(Qt.DefaultContextMenu)
		self.header().setResizeMode(0, QHeaderView.Interactive)
		self.header().resizeSection(0, 100)
		self.header().setResizeMode(1, QHeaderView.Interactive)

	def setModel(self, templateModels):
		self._templateModels = templateModels
		self.refresh()

	def getModel(self):
		return self._templateModels

	def refresh(self):
		self.clear()
		for templateModel in self._templateModels:
			TemplateItem(templateModel, self)

		self.sortItems(self.header().sortIndicatorSection(), self.header().sortIndicatorOrder())

	def __createActions(self):
		self._addTemplateAction = TestermanAction(self, "New template...", self._addTemplate)
		self.addAction(self._addTemplateAction)
		self._removeTemplateAction = TestermanAction(self, "Remove template...", self._removeTemplate)
		self.addAction(self._removeTemplateAction)
		self._modifyTemplateAction = TestermanAction(self, "Modify template...", self._modifyTemplate)
		self.addAction(self._modifyTemplateAction)

	def _addTemplate(self):
		dialog = TemplateEditDialog(parent = self)
		if dialog.exec_() == QDialog.Accepted:
			self._templateModels.append(dialog.getModel())
			self.refresh()

	def _modifyTemplate(self):
		item = self.currentItem()
		if item:
			model = item.getModel()
			dialog = TemplateEditDialog(model, parent = self)
			if dialog.exec_() == QDialog.Accepted:
				dialog.updateModel()
				self.refresh()

	def _removeTemplate(self):
		item = self.currentItem()
		if item:
			model = item.getModel()
			ret = QMessageBox.question(self, "Remove Template", 
				"Are you sure you want to remove the template %s?\n(The template file won't be deleted)" % unicode(model.getName()),
				QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
			if ret == QMessageBox.Yes:
				try:
					self._templateModels.remove(model)
				except:
					pass

			self.refresh()

	def onItemActivated(self, item, col):
		self._modifyTemplate()

	def contextMenuEvent(self, event):
		item = self.itemAt(event.pos())
		menu = QMenu(self)
		if item:
			menu.addAction(self._modifyTemplateAction)
			menu.addAction(self._removeTemplateAction)
			menu.addSeparator()
		# In any case, general action
		menu.addAction(self._addTemplateAction)
		menu.popup(event.globalPos())
	
class WPluginConfiguration(Plugin.WPluginConfiguration):
	def __init__(self, parent = None):
		Plugin.WPluginConfiguration.__init__(self, parent)
		self.__createWidgets()

	##
	# Plugin.WPluginConfiguration reimplementation
	##
	def displayConfiguration(self):
#		path = "plugins/%s" % PLUGIN_ID
#		# Read the settings
#		settings = QSettings()
#		# templatePath = settings.value(path + '/templatePath', QVariant(QString(QApplication.instance().get('qtestermanpath')))).toString()
		
		templateModels = loadTemplates()
		self._templateView.setModel(templateModels)

	def saveConfiguration(self):
#		settings = QSettings()
#		path = "plugins/%s" % PLUGIN_ID
#		# settings.setValue(path + '/templatePath', QVariant(self.templatePathLineEdit.text()))
		
		ret = saveTemplates(self._templateView.getModel())
		return ret

	def checkConfiguration(self):
		return True

	##
	# Implementation specific
	##
	def __createWidgets(self):
		self.setMinimumWidth(350)
		layout = QVBoxLayout()

		self._templateView = WTemplateTreeView()
		layout.addWidget(self._templateView)

		self.setLayout(layout)



PluginManager.registerPluginClass("Simple Reporter", PLUGIN_ID, WReportView, WPluginConfiguration, version = VERSION, description = DESCRIPTION)

