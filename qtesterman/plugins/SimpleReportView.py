# -*- coding: utf-8 -*-
##
# This file is part of Testerman, a test automation system.
# Copyright (c) 2009 QTesterman contributors
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
##

##
# A plugin to display logs as a simple text summary.
#
##

from PyQt4.Qt import *
from PyQt4.QtXml import *

from Base import *
from CommonWidgets import *

import Plugin
import PluginManager

# Plugin ID, as generated by uuidgen
PLUGIN_ID = "86d2d0a0-266e-4735-bb25-54378c7b1a1d"
VERSION = "1.0.0"
DESCRIPTION = """
A simple reporter that creates a text-based report with the following properties:
<ul>
	<li>TC ID, verdict, description</li>
	<li>If the verdict is not pass, contains user logs</li>
</ul>
"""

# docstring trimmer - from PEP 257 sample code
# Used to trim descriptions from old Testerman versions that
# did not trim the docstrings by themselves
def trim(docstring):
	if not docstring:
		return ''
	maxint = 2147483647
	# Convert tabs to spaces (following the normal Python rules)
	# and split into a list of lines:
	lines = docstring.expandtabs().splitlines()
	# Determine minimum indentation (first line doesn't count):
	indent = maxint
	for line in lines[1:]:
		stripped = line.lstrip()
		if stripped:
			indent = min(indent, len(line) - len(stripped))
	# Remove indentation (first line is special):
	trimmed = [lines[0].strip()]
	if indent < maxint:
		for line in lines[1:]:
			trimmed.append(line[indent:].rstrip())
	# Strip off trailing and leading blank lines:
	while trimmed and not trimmed[-1]:
		trimmed.pop()
	while trimmed and not trimmed[0]:
		trimmed.pop(0)
	# Return a single string:
	return '\n'.join(trimmed)

##
# Local classes: we structure an ATS as an Ats instance that aggregates 0..N
# TestCase instances.
##

class Testcase:
	def __init__(self, id_):
		self._id = id_
		self._description = ''
		self._verdict = ''
		self._title = ''
		self._startTimestamp = 0.0
		self._stopTimestamp = 0.0
		self._logs = []
	
	def getDuration(self):
		return self._stopTimestamp - self._startTimestamp
	
	def getVerdict(self):
		return self._verdict
	
	def getDescription(self):
		return self._description
	
	def getId(self):
		return self._id
	
	def getTitle(self):
		return self._title
	
	def appendLog(self, timestamp, log):
		self._logs.append((timestamp, log))
	
	def toString(self):
		ret = []
		ret.append('%s' % self._id)
		ret.append('Verdict: %s' % self._verdict)
		if self._title:
			ret.append('Title: %s' % self._title)
		ret.append('Duration: %ss' % int(self.getDuration()))
		if self._description:
			ret.append('Description:\n%s' % self._description)
		if self._logs:
			ret.append('User logs:')
			for timestamp, log in self._logs:
				d = QDateTime()
				d.setTime_t(int(timestamp - self._startTimestamp))
				ret.append('%s: %s' % (d.toString('+hh:mm:ss'), log))

		return '\n'.join(ret)
	
	
class Ats:
	def __init__(self, id_):
		self._id = id_
		self._retcode = None
		self._testcases = []
		self._startTimestamp = 0.0
		self._stopTimestamp = 0.0
	
	def getDuration(self):
		return self._stopTimestamp - self._startTimestamp

	def getId(self):
		return self._id
	
	def appendTestcase(self, testcase):
		self._testcases.append(testcase)
	
	def getTestcases(self):
		return self._testcases
	
	def getSummary(self):
		ret = []
		count = 0
		counts = {}
		for s in ['pass', 'fail', 'other']:
			counts[s] = 0
		for tc in self._testcases:
			v = unicode(tc.getVerdict())
			ret.append('%s: %s' % (tc.getId(), v))
			if v in counts:
				counts[v] = counts[v] + 1
			count += 1
		
		ret.insert(0, 'Summary: %s testcases, %s%s passed, %s%s failed' % (count, 
			counts['pass'], count and ' (%2.2f%%)' % (float(counts['pass'])/float(count)*100.0) or '',
			counts['fail'], count and ' (%2.2f%%)' % (float(counts['fail'])/float(count)*100.0) or ''))

		return '\n'.join(ret)


class WSimpleLogView(Plugin.WReportView):
	def __init__(self, parent = None):
		Plugin.WReportView.__init__(self, parent)
		
		self._ats = None
		self._currentTestcase = None
		
		self.__createWidgets()
	
	##
	# Implementation specific
	##
	def __createWidgets(self):
		layout = QVBoxLayout()

		# The text view
		self._textView = QTextEdit()
		self._textView.setReadOnly(1)
		font = QFont("courier", 8)
		font.setFixedPitch(True)
		font.setItalic(False)
		self._textView.setFont(font)
		self._textView.setLineWrapMode(QTextEdit.NoWrap)
		layout.addWidget(self._textView)
		
		self.setLayout(layout)

	##
	# Plugin.WReportView reimplementation
	##
	def onEvent(self, domElement):
		tc = self._currentTestcase
		tag = domElement.tagName()
		if tag == 'ats-started':
			self._ats = Ats(domElement.attribute('id'))
		elif not self._ats:
			return # 
		elif tag == 'ats-stopped':
			self._ats._retcode = domElement.attribute('result')
		elif tag == 'testcase-started':
			self._currentTestcase = Testcase(domElement.attribute('id'))
			self._currentTestcase._title = unicode(domElement.text()).strip()
			self._currentTestcase._startTimestamp = float(domElement.attribute('timestamp'))
		elif not tc:
			return
		elif tag == 'testcase-stopped':
			tc._stopTimestamp = float(domElement.attribute('timestamp'))
			tc._verdict = domElement.attribute('verdict')
			tc._description = trim(unicode(domElement.text()))
			self._ats.appendTestcase(tc)
			self._currentTestcase = None
		elif tag == 'user':
			tc.appendLog(float(domElement.attribute('timestamp')), domElement.text())
	
	def displayLog(self):
		if self._ats:
			self._textView.append(self._ats.getSummary())
			self._textView.append('\n')
			self._textView.append('\n')
			for tc in self._ats.getTestcases():
				self._textView.append(tc.toString())
				self._textView.append('\n')
	
	def clearLog(self):
		self._ats = None
		self._currentTestcase = None
		self._textView.clear()
		


class WSimpleLogViewConfiguration(Plugin.WPluginConfiguration):
	def __init__(self, parent = None):
		Plugin.WPluginConfiguration.__init__(self, parent)
		self.__createWidgets()

	##
	# Plugin.WPluginConfiguration reimplementation
	##
	def displayConfiguration(self):
		path = "plugins/%s" % PLUGIN_ID
		# Read the settings
		settings = QSettings()
		# xsltPath = settings.value(path + '/xsltpath', QVariant(QString(QApplication.instance().get('qtestermanpath')))).toString()

	def saveConfiguration(self):
		settings = QSettings()
		path = "plugins/%s" % PLUGIN_ID
		# settings.setValue(path + '/xsltpath', QVariant(self.xlstPathLineEdit.text()))
		return True

	def checkConfiguration(self):
		return True

	##
	# Implementation specific
	##
	def __createWidgets(self):
		layout = QVBoxLayout()

		self.setLayout(layout)



PluginManager.registerPluginClass("Simple Reporter", PLUGIN_ID, WSimpleLogView, WSimpleLogViewConfiguration, version = VERSION, description = DESCRIPTION)

